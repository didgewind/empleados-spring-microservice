Esta versión tira de spring boot 2.0

Ésta es la rama para pruebas Saga y CQRS. En este commit enviamos un EmpleadosEvent con info del empleado
que acabamos de eliminar / crear. Recibimos la respuesta back en SagaEventsListener, donde tenemos el código
de confirmación / rollback medio asá.

Cuando creamos un empleado el mensaje que enviamos siempre lo asigna al departamento de Recursos Humanos.

Todo esto lo configuramos entre el .yml, el negocio y el paquete Saga
(usando un KafkaTemplate y un SagaEventsListener).

Para que funcione todo previamente necesitamos lanzar kafka y crear el topic (con las tres particiones)
con los siguientes comandos (desde el folder kafka, en mi caso ~/applications/kafka_2.13-2.8.0):

	bin/zookeeper-server-start.sh -daemon config/zookeeper.properties

	bin/kafka-server-start.sh -daemon config/server.properties
	
	bin/kafka-topics.sh --create --topic empleados-events --replication-factor 1 \
    --partitions 3 --bootstrap-server localhost:9092

	bin/kafka-topics.sh --create --topic saga-control-events --replication-factor 1 \
    --partitions 3 --bootstrap-server localhost:9092

Podemos probar que el servicio de empleados (y el de departamentos) están enviando / recibiendo
datos lanzando un par de consumidores de esta manera:

	bin/kafka-console-consumer.sh --topic empleados-events --from-beginning --bootstrap-server localhost:9092
	
para lanzar el consumidor de eventos del servicio de departamentos ejecutar el mismo comando
sustituyendo empleados-events por saga-control-events

* empleados spring-boot (puerto aleatorio): microservicio rest de empleados tirando de mysql. 
Usa i18n para el mensaje de bienvenida. Hemos añadido una línea en el .properties para poder lanzar
diferentes instancias del servicio y probar balance de carga. Para lanzar diferentes instancias simplemente
hay que ejecutar la app, porque el puerto está configurado para que se elija aleatoriamente.

	- Tres daos - uno en memoria, el otro inmutable que siempre devuelve el mismo empleado
	  y un spring jdbc que ataca empleados_simple.
	  
	- Una clase java config para instanciar DAODumb.
	
	- Un controlador Home que redirige / a /index.jsp
	  
	- Un controlador Rest que funciona con JSON y XML y mapea a /empleados/ y sus derivados. Si probamos
	  directamente con el navegador va a devolver xml (por la cabecera que se envía, creo). El Json
	  se puede probar con Postman. Su api es:
	
		- GET /empleados/: devuelve todos los empleados
		- GET /empleados/x: devuelve el empleado con cif x
		- PUT /empleados/: modifica un empleado (sólo admin)
		- DELETE /empleados/x: elimina el empleado con cif x (sólo admin)
		- POST /empleados/: inserta un empleado (sólo admin)
		
	  ATENCIÓN, EL API LO HEMOS CAMBIADO A PARTIR DE ESTE COMMIT, AHORA POST Y PUT ESTÁN INTERCAMBIADOS.
	  LA SINTÁXIS POST QUE USO NO ES TOTALMENTE CORRECTA (VER https://restfulapi.net/rest-put-vs-post/
	  Y COMENTARIOS) PERO ME VALE COMO EJEMPLO
		
	  Trabaja con Json y xml porque Spring detecta las librerías Jackson en el path y 
	  utiliza httpmessageconverters. Es por ello que al hacer la misma petición REST 
	  con un navegador web y Postman el segundo devuelve siempre JSON pero el primero puede devolver xml
	  (depende de la cabecera de aceptación de respuesta que envía el cliente).
	  
	  Devuelve cabeceras con código de error en caso de que se produzcan (por ejemplo, NOT_FOUND en caso
	  de delete o get de un cif que no existe, o CONFLICT si el empleado está repetido)
	  
	- Implementamos seguridad con java config con un usuario profe / profe o administrador admin / admin mediante
	  la clase profe.empleados.mvc.security.EmpleadosWebSecurityConfig.  Añadimos {noop} como prefijo al
	  declarar las contraseñas (transparente para el cliente) para saltarnos el requerimiento
	  de security 5.x de que las contraseñas estén hashcodeadas. Podemos utilizar postman para
	  invocaciones directas (fichero de config en la carpeta postman) o el navegador.
	  El /logout está implementado y ahora ya funciona. Para hacer logout en Postman necesitamos
	  cambiar a No Auth en la colección padre y borrar la cookie de la petición

	- EmpleadosApp arranca el servidor embebido.

- Sobre el logout (cogido del proyecto 'empleados hb spring mvc sec ws 4' del workspace
'spring completo'): parece que desde la versión 4 de spring security 
el logout por defecto sólo
funciona cuando hacemos una petición de logout POST enviando un csrf (ver apuntes de seguridad
spring). Para habilitar el logout get lo podemos hacer deshabilitando el csrf (como hacemos
en el proyecto mencionado al configurar la seguridad de forma declarativa) o mediante el código que
se encuentra en la clase WebSecurityConfig del mismo proyecto (que respeta el csrf).

